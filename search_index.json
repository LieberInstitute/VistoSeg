[["index.html", "VisiumLIBD: Visium Image Processing Pipeline Overview Cite VisiumLIBD", " VisiumLIBD: Visium Image Processing Pipeline Madhavi Tippani true Overview Visium imaging is a part of whole spatial transcriptomics workflow, a barcoding-based transcriptome-wide technology released by 10X genomics. (https://www.10xgenomics.com/products/spatial-gene-expression) ##Why spatial transcriptomics or visium imaging?? Methods like RNAseq can profile single cells transcriptome-wide and enable researchers to identify cell type compositions but can necessarily destroy the spatial information. Multiplexing methods on other hand can provide spatial information but has significant limitations on the number of genes that can be processed and has issues with microscopy and related computational challenges. spatial transcriptomics provides solutions to these limitations allowing us to quantify gene expression with high spatial resolution. The key to this system is the visium imaging and visium gene expression slide, where the tissue sections from subjects goes onto the capture areas(green squares) on the slide. The whole slide is imaged at once and produces a huge output image file with all capture areas. The whole slide image has to be split into individual capture area images(necessarily JPEG or tiff) and processed accordingly for the downstream analysis. This website describes the steps required to split, visualize and process the visium images from spatial transcriptomics projects generated by the 10x Genomics Visium commercial platform. The above figure describes the VisiumLIBD pipeline, where sections (A) and (B) correspond to visium imaging and the rest describes the workflow in a step-by-step procedure. (C) First, the whole slide image is split into the respective capture areas. (D) Then the nuclei from individual tiffs are segmented using Kmeans color based segmentation (E) The output tiff files from (D) serve as input into the Spaceranger module for subsequent spatial transcriptomics processing and analysis. (F) Next we extract nuclei count per visium spot in the image. (G) Finally, the pipeline provides a GUI that allows the user to perform visual inspection of the segmentations by allowing the user to toggle between the visium and binary images, and also by providing zoom in/out options to clearly see the nuclei in the visium spot. Cite VisiumLIBD We hope that VisiumLIBD will be useful for your research. Please use the following information to cite the package and the overall approach. Thank you! @article {, author = {Tippani, Madhavi and other names to include}, title = {VisiumLIBD: a semiautomated Matlab pipeline for visualizing and processing high resolution visium images whose output is used for downstream spatial transcriptomics analyis}, elocation-id = {}, year = {2021}, doi = {}, publisher = {Oxford Bioinformatics}, abstract = {}, URL = {https://www.overleaf.com/read/fmvrpsyxgsbz}, eprint = {https://www.overleaf.com/read/fmvrpsyxgsbz}, journal = {bioRxiv} } This is a project by the Imaging Development Team from Keri Martinowich’s Lab at the Lieber Institute for Brain Development. "],["step-1-split-histology-images-into-subsections.html", "1 Step 1: Split histology images into subsections", " 1 Step 1: Split histology images into subsections The raw histology image file from the slide scanner (JHU imaging core) is a multiplane tif file. The sample Lieber_Institute_OTS-20-7748_rush_posterior.tif (DLPFC data) is used here to run through the pipeline. The tif file is loaded and saved as matlab structure as shown below. fname = &#39;/dcl02/lieber/ajaffe/SpatialTranscriptomics/LIBD/spatialDLPFC/Images/Liebert_Institute_OTS-20-7748_rush_posterior.tif&#39;; numimgs = size(imfinfo(fname),1); %numimgs is the number of images in the tif file parfor i = 1:numimgs tic I{i}.image = imread(fname,i); toc disp(num2str(i)) end %save tif image in mat format save([fname(1:end-4),&#39;.mat&#39;],&#39;I&#39;, &#39;-v7.3&#39;); This sample tif file has 7 images (numimgs = 7) shown below. Though most of the images look same, the first image in the tif stack/file is the high resolution image of the slide, which was based on the image size (y,x,z dimensions) in pixels shown below in matlab. &gt;&gt; size(I{1}.image) ans = 53384 160858 3 &gt;&gt; size(I{2}.image) ans = 339 1024 3 &gt;&gt; size(I{3}.image) ans = 13346 40214 3 &gt;&gt; size(I{4}.image) ans = 3336 10053 3 &gt;&gt; size(I{5}.image) ans = 834 2513 3 &gt;&gt; size(I{6}.image) ans = 777 765 3 &gt;&gt; size(I{7}.image) ans = 612 1600 3 The image (Img) is split into 4 sub images (Img1,Img2,Img3,Img4) by dividing the x(160858) dimesion into 4 equal parts. Sometimes the center of the image is not the center of the slide, in such case the offset is adjusted manually. Each sub image is resized to 70% of the original size (eg 100 X 100 Pixel region is resized to 70 X 70 pixel region) and saved as individual tif and mat files in the same location as the raw tif file. Images are resized as matlab cannot store images that occupies more than 2^32 - 1 bytes of data. Img = I{1}.image; [y,x,z] = size(Img); Img1 = Img(:,1:round(x/4),:); Img2 = Img(:,round(x/4):round(x/4)*2,:); Img3 = Img(:,round(x/4)*2:round(x/4)*3,:); Img4 = Img(:,round(x/4)*3:end,:); IMG1 = imresize(Img1,0.7); IMG2 = imresize(Img2,0.7); IMG3 = imresize(Img3,0.7); IMG4 = imresize(Img4,0.7); for i = 1:4 save([&#39;/dcl02/lieber/ajaffe/SpatialTranscriptomics/LIBD/spatialDLPFC/Images/Lieber_Institute_OTS-20-7748_rush_posterior_&#39;,num2str(i),&#39;.mat&#39;],[&#39;Img&#39;,num2str(i)],&#39;-v7.3&#39;); eval([&#39;imwrite(IMG&#39;,num2str(i),&#39;,&#39;&#39;/dcl02/lieber/ajaffe/SpatialTranscriptomics/LIBD/spatialDLPFC/Images/Lieber_Institute_OTS-20-7748_rush_posterior_&#39;,num2str(i),&#39;.tif&#39;&#39;)&#39;]); end "],["step-2-segment-nuclei-from-each-histology-subsection.html", "2 Step 2: Segment nuclei from each histology subsection 2.1 Intensity thresholding 2.2 Kmeans segmentation", " 2 Step 2: Segment nuclei from each histology subsection We have been using two methods for nuclei segmentation in histology images. Intensity thresholding: works fine with high resolution images Kmeans color based segmentation: works well with low contrast, noisy background, low resolution images. (ex: 10x images) The following shows both the segmentations for the 1st sub image of Lieber_Institute_OTS-20-7748_rush_posterior.tif used is Step1. 2.1 Intensity thresholding fname = &#39;/dcl02/lieber/ajaffe/SpatialTranscriptomics/LIBD/spatialDLPFC/Images/Liebert_Institute_OTS-20-7748_rush_posterior_1.tif&#39;; Img = imread(fname,1); thresh = graythresh(rgb2gray(Img)); BW = imbinarize(rgb2gray(Img),thresh); save(&#39;/dcl02/lieber/ajaffe/SpatialTranscriptomics/LIBD/spatialDLPFC/Images/Liebert_Institute_OTS-20-7748_rush_posterior_1_nucleisegmentation.mat&#39;,&#39;BW&#39;) imwrite(BW,&#39;/dcl02/lieber/ajaffe/SpatialTranscriptomics/LIBD/spatialDLPFC/Images/Liebert_Institute_OTS-20-7748_rush_posterior_1_nucleisegmentation.tif&#39;) 2.2 Kmeans segmentation fname = &#39;/dcl02/lieber/ajaffe/SpatialTranscriptomics/LIBD/spatialDLPFC/Images/Liebert_Institute_OTS-20-7748_rush_posterior_1.tif&#39;; Img = imread(fname,1); Img_smooth = imgaussfilt(Img,4); Img_smooth_adj = imadjust(Img_smooth, [.2 .3 0; .6 .7 1],[]); he = Img_smooth_adj; lab_he = rgb2lab(he); ab = lab_he(:,:,2:3); ab = im2single(ab); nColors = 5; pixel_labels = imsegkmeans(ab,nColors,&#39;NumAttempts&#39;,3); parfor i = 1:nColors mask{i} = pixel_labels==i; cluster{i} = he .* uint8(mask{i}); end nuclei_mask = mask{4}; imwrite(cluster{4},&#39;/dcl02/lieber/ajaffe/SpatialTranscriptomics/LIBD/MiSeq_Pilot/Images/Raw/Lieber-Institute_OTS-20-7748_rush_posterior_1_cluster4Nuclei.tif&#39;) save(&#39;/dcl02/lieber/ajaffe/SpatialTranscriptomics/LIBD/MiSeq_Pilot/Images/Raw/Lieber-Institute_OTS-20-7748_rush_posterior_1_nucleisegmentation.mat&#39;,&#39;nuclei_mask&#39;) "],["step-3-run-spaceranger.html", "3 Step 3: Run spaceranger", " 3 Step 3: Run spaceranger The following links and the flowchart provide useful information for running spaceranger on histology images. Blog post on running spaceranger on JHPCE, link to the github repo for running spaceranger, video tutorial etc. flow chart for running spaceranger The output files scalefactors_json.json and tissue_positions_list.csv from the spaceranger saved in the spatial folder, are required for the following image processing steps. "],["step-4-spotspotcheck-for-quality-check-on-nuclei-segmentations-and-counts.html", "4 Step 4: spotspotcheck for quality check on nuclei segmentations and counts", " 4 Step 4: spotspotcheck for quality check on nuclei segmentations and counts It is a matlab GUI for performing quality check on the nuclei segmentations from Step2. It also gives the nuclei count in each spot and provides an option to save/concatenate the count data to the tissue_positions_list.csv file. We will extract the metrics like spot diameter, distance between spots from the scalefactors_json.json and number of spots from tissue_positions_list.csv to reconstruct the spot grid for spotspotcheck. Describe what each column and row are in the tissue_positions_list.csv link to the video tutorial on the spotspotcheck GUI by Jeo Catallini Commands to run on matlab to perform nuclei counting per spot and adding the same as new column to tissue_positions_list.csv code and output for the command goes here "],["step-5-atlasaligner.html", "5 Step 5: AtlasAligner", " 5 Step 5: AtlasAligner "],["r-session-information.html", "R session information", " R session information Details on the R version used for making this book. The source code is available at LieberInstitute/VisiumLIBD. ## Load the package at the top of your script library(&quot;sessioninfo&quot;) ## Reproducibility information options(width = 120) session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.3 (2020-10-10) ## os Ubuntu 20.04 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2021-04-26 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [2] RSPM (R 4.0.3) ## bookdown 0.21 2020-10-13 [1] RSPM (R 4.0.2) ## cli 2.3.0 2021-01-31 [2] RSPM (R 4.0.3) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.0.3) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.0.3) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.0.3) ## htmltools 0.5.1.1 2021-01-22 [2] RSPM (R 4.0.3) ## knitr 1.31 2021-01-27 [2] RSPM (R 4.0.3) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.0.3) ## rlang 0.4.10 2020-12-30 [2] RSPM (R 4.0.3) ## rmarkdown 2.6 2020-12-14 [1] RSPM (R 4.0.3) ## rstudioapi 0.13 2020-11-12 [2] RSPM (R 4.0.3) ## sessioninfo * 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [2] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.0.3) ## withr 2.4.1 2021-01-26 [2] RSPM (R 4.0.3) ## xfun 0.21 2021-02-10 [2] RSPM (R 4.0.3) ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.0.3) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library proc.time() ## user system elapsed ## 0.609 0.102 0.584 This book was last updated at 2021-04-26 16:40:23. "]]
