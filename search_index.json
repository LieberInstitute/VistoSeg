[["index.html", "VisiumLIBD: Visium Image Processing Pipeline Overview Why spatial transcriptomics or visium imaging?? Cite VisiumLIBD Image Acquisition Software Requirements Data Availability Pipeline Outputs", " VisiumLIBD: Visium Image Processing Pipeline Madhavi Tippani true Overview Visium imaging is a part of whole spatial transcriptomics workflow, a barcoding-based transcriptome-wide technology released by 10X genomics. Why spatial transcriptomics or visium imaging?? Methods like RNAseq can profile single cells transcriptome-wide and enable researchers to identify cell type compositions but can necessarily destroy the spatial information. Multiplexing methods on other hand can provide spatial information but has significant limitations on the number of genes that can be processed and has issues with microscopy and related computational challenges. spatial transcriptomics provides solutions to these limitations allowing us to quantify gene expression with high spatial resolution. The key to this system is the visium imaging and visium gene expression slide, where the tissue sections from subjects goes onto the capture areas(A1,B1,C1,D1) on the slide. The whole slide is imaged at once and produces a huge output image file with all capture areas. The whole slide image has to be split into individual capture area images (necessarily JPEG or tiff) and processed accordingly for the downstream analysis. This website describes the steps required to split, visualize and process the visium images from spatial transcriptomics projects generated by the 10x Genomics Visium commercial platform. The above figure describes the VisiumLIBD pipeline, (A) The data presented here is from a portion of DLPFC (taken from posterior, mid and anterior sections of brain per sample) that spans six neuronal layers plus white matter. (B) Shows the original ‘Visium gene expression slide’ with 4 capture areas and the slide scanner used to image the slide. (C) Shows the huge tiff file produced by the slide scanner which is then split into the respective capture areas using the function splitSlide described in Step 1 (D) Shows the individual tiff images of capture areas produced by ‘splitVisium’ and its corresponding nuclei segmentations produced by the functions VNS (Visium Nuclei Segmentation) and refineVNS explained in Step 2 (E) The tiff images from ‘D’ serve as input to the Spaceranger module (explained in Step 3) which generates tissue_positions_list.csv file and scalefactors_json.json file that contain ‘Visium spot metrics’ (F) The function countNuclei explained in Step 4, gives the nuclei count per visium spot info that is stored in tissue_spot_counts.csv file (G) Finally, the pipeline provides a GUI called spotspotcheck that allows the user to perform visual inspection of the nuclei segmentations by allowing the user to toggle between the visium and binary images, and also by providing zoom in/out options to clearly see the nuclei inside a visium spot. Cite VisiumLIBD We hope that VisiumLIBD will be useful for your research. Please use the following information to cite the package and the overall approach. Thank you! @article {, author = {Tippani, Madhavi and other names to include}, title = {VisiumLIBD: a semiautomated MATLAB pipeline for visualizing and processing high resolution visium images whose output is used for downstream spatial transcriptomics analyis}, elocation-id = {}, year = {2021}, doi = {}, publisher = {Oxford Bioinformatics}, abstract = {}, URL = {https://www.overleaf.com/read/fmvrpsyxgsbz}, eprint = {https://www.overleaf.com/read/fmvrpsyxgsbz}, journal = {bioRxiv} } This is a project by the Imaging Development Team from Keri Martinowich’s Lab at the Lieber Institute for Brain Development. Image Acquisition The 10X Visium Spatial Gene Expression Imaging Guidelines are followed for acquiring the images. Images are acquired at 40x magnification using a Leica CS2 slide scanner and saved as .SVS files. These .SVS files are then exported as TIFF files for downstream analysis. The entire Visium slide (4 capture areas with fiducial frames), is scanned in a single file (~20GB). Software Requirements The pipeline was developed under the following software configuration. VisiumLIBD has been tested on Linux, Windows and MacOS. MATLAB {-} MATLAB version R2019a 64-bit or later is required to run VisiumLIBD pipeline with the Image Processing Toolbox preloaded. Memory {-} Visium whole slide images are high resolution, and the typical size of these multiplane tif images produced inhouse is ~25GB. The system RAM (we use ~75GB) should be thrice the size of the multiplane tif image to load it into MATLAB and the disc space (we use ~100GB) should be atleast 4 times the size of multiplane tif to store the output. Installation {-} The pipeline is availble at (https://github.com/LieberInstitute/VisiumLIBD) which can be download to your system from the Github website directly or the main repository can be cloned to your system using the following command on terminal/command prompt. git clone https://github.com/LieberInstitute/VisiumLIBD.git All the code exists in the code directory inside the main VisiumLIBD directory. The user’s working directory on MATLAB should be the path to the code directory in the downloaded repository, to run any functions this pipeline provides. Once the repository is downloaded, the user can run either of the following code to change his/her working directory on MATLAB to the code directory. 1. cd /path_to_the_downloaded_repository/VisiumLIBD/code/ 2. addpath(genpath('/path_to_the_downloaded_repository/VisiumLIBD/code/')) Data Availability The data is hosted at the link to AWS I started building the repo based on the sample from new DLPFC data, the functions I recently made for the pipeline, works fine on the new DLPFC data. The pipeline should run fine on the 10X data and the pilot DLPFC data too, but is it troublesome to make the new DLPFC data public? Atleast, one sample from new DLPFC data should be good. Other potential datasets 1. LIBD pilot DLPFC, 2. 10x Genomics spatial data sets Pipeline Outputs splitSlide should be hosted on AWS as these will be ~2GB VNS (should be hosted by AWS) refineVNS Mat file of final nuclei segmentation, tif image of final nuclei segmentation Spaceranger tissue_positions_list.csv, scalefactors_json.json spotspotcheck *tissue_spot_counts.csv "],["step-1-split-visium-histology-whole-slide-image-into-individual-capture-area-images.html", "1 Step 1: Split Visium histology whole slide image into individual capture area images", " 1 Step 1: Split Visium histology whole slide image into individual capture area images The visium histology whole slide image from the imaging system (slide scanner) is a multiplane tif image (~20GB). The sample image Lieber_Institute_OTS-20-7690_rush_anterior.tif from the DLPFC dataset is used here to run through the pipeline. The inputs to the function splitSlide.m are 1. the full path with file name of the raw multiplane tif image (obtained from slide scanner) The function imports the raw multiplane tif image and saves each plane/image as MATLAB structure and all structures are saved into a single cell array (I) in a ‘.mat file’. The 1st image of the raw multiplane tif is the raw visium histology slide image, the remaining planes/images consists of the metadata. The function then splits the 1st image of the multiplane tif into individual capture areas (A1,B1,C1,D1) and saves them as both tif images and mat files. The capture areas are resized to 70% of the original size (eg 100 X 100 Pixel region is resized to 70 X 70 pixel region) when saving to tif images as MATLAB cannot store images that occupies more than 2^32 - 1 bytes of data. &gt;&gt; cd /path_to_downloaded_repo/VisiumLIBD/code &gt;&gt; fname = &#39;/path_to_multiplane_tif/Lieber_Institute_OTS-20-7690_rush_anterior.tif&#39;; &gt;&gt; splitSlide(fname) The multiplane tif has 7 images Starting parallel pool (parpool) using the &#39;local&#39; profile ... Imported image 7 of the multiplane tif Elapsed time is 0.067836 seconds. Imported image 6 of the multiplane tif Elapsed time is 0.030412 seconds. Imported image 5 of the multiplane tif Elapsed time is 0.046113 seconds. Imported image 4 of the multiplane tif Elapsed time is 0.646907 seconds. Imported image 3 of the multiplane tif Elapsed time is 10.682875 seconds. Imported image 2 of the multiplane tif Elapsed time is 0.010540 seconds. Imported image 1 of the multiplane tif Elapsed time is 165.635605 seconds. Saving the multiplane tif to mat file Elapsed time is 1094.729705 seconds. Splitting image Elapsed time is 18.653927 seconds. The 7 images of the multiplane tif are shown below. Though most of the images look same, the first image in the multiplane tif is the high resolution image of the slide based on the image size (y,x,z) in pixels shown below in MATLAB. load(&#39;/path_to_multiplane_tif/Lieber_Institute_OTS-20-7748_rush_posterior.mat&#39;) size(I,2) %number of images in the multiplane tif size(I{1}.image) ans = 53384 160858 3 size(I{2}.image) ans = 339 1024 3 size(I{3}.image) ans = 13346 40214 3 size(I{4}.image) ans = 3336 10053 3 size(I{5}.image) ans = 834 2513 3 size(I{6}.image) ans = 777 765 3 size(I{7}.image) ans = 612 1600 3 The image ‘I{1}.image’ is split into 4 sub images or capture areas by dividing the x(160858) dimesion into 4 equal parts. Sometimes the center of the image is not the center of the slide, in such case the offset is adjusted manually. Below are the output files of slpitSlide function 1. Lieber_Institute_OTS-20-7690_rush_anterior.mat - cell array of multiplane tif stored in mat file. 2. Lieber_Institute_OTS-20-7690_rush_anterior_A1.tif - tif image of compressed capture area A1. 3. Lieber_Institute_OTS-20-7690_rush_anterior_A1.mat - RGB matrix of uncompressed capture area A1 stored in mat file. 4. Lieber_Institute_OTS-20-7690_rush_anterior_B1.tif - tif image of compressed capture area B1. 5. Lieber_Institute_OTS-20-7690_rush_anterior_B1.mat - RGB matrix of uncompressed capture area B1 stored in mat file. 6. Lieber_Institute_OTS-20-7690_rush_anterior_C1.tif - tif image of compressed capture area C1. 7. Lieber_Institute_OTS-20-7690_rush_anterior_C1.mat - RGB matrix of uncompressed capture area C1 stored in mat file. 8. Lieber_Institute_OTS-20-7690_rush_anterior_D1.tif - tif image of compressed capture area D1. 9. Lieber_Institute_OTS-20-7690_rush_anterior_D1.mat - RGB matrix of uncompressed capture area D1 stored in mat file. "],["step-2-nuclei-segmentation-of-individual-capture-areas-images.html", "2 Step 2: Nuclei segmentation of individual capture areas images 2.1 VNS - Visium Nuclei Segmentation 2.2 refineVNS", " 2 Step 2: Nuclei segmentation of individual capture areas images The functions VNS(Visium Nuclei Segmentation) and refineVNS from the pipeline are used to perform nuclei segmentation. 2.1 VNS - Visium Nuclei Segmentation The inputs to the VNS function are 1. The tif image of single capture area (output from Step 1: splitSlide function) with full path 2. number of colors a user visually identifies in the single capture area image The VNS function imports the capture area image, applies smoothening to it to get rid of any irregularities in the image and increases the contrast to brighten the nuclei for better detection. This function is based on Color-Based Segmentation Using K-Means Clustering. The smoothened and brightened image is converted from RGB color space to CIELAB color space also called L*a*b color space (L - Luminosity layer measures lightness from black to white, a - chromaticity-layer measures color along red-green axis, b - chromaticity-layer measures color along blue-yellow axis). The CIELAB color space quantifies the visual differences caused by the different colors in the image. The a*b color space is extracted from the L*a*b converted image and is given to the K-means clustering along with the number of colors the user visually identifies in the image. The VNS function partitions the image into n (number provided by user, 5 for the sample used here) color clusters and saves them as individual objects with a index/label. The color clusters (cell array), the indexed objects (cell array) of the color clusters, images of the color clusters (tif) are all saved in the same location as the capture area tif image. fname = &#39;/path_to_capture_area_tif/Lieber_Institute_OTS-20-7690_rush_anterior_A1.tif&#39;; N = 5; % 5 (white,pink,dark pink,cream,blue) colors seem good for the images produced in-house VNS(fname,N) % should add the output printed on matlab command prompt Below are the outputs of VNS function 1. Lieber_Institute_OTS-20-7690_rush_anterior_A1_cluster1.tif 2. Lieber_Institute_OTS-20-7690_rush_anterior_A1_cluster2.tif 3. Lieber_Institute_OTS-20-7690_rush_anterior_A1_cluster3.tif 4. Lieber_Institute_OTS-20-7690_rush_anterior_A1_cluster4.tif 5. Lieber_Institute_OTS-20-7690_rush_anterior_A1_cluster5.tif 6. Lieber_Institute_OTS-20-7690_rush_anterior_A1_cluster.mat 7. Lieber_Institute_OTS-20-7690_rush_anterior_A1_mask.mat The color clusters and the corresponding indexed objects of the sample image are shown below. 2.2 refineVNS This function is used to refine the segmentations for accurate detection of nuclei. The inputs to the function are 1. The tif image of a single capture area with full path 2. The index of the color cluster of the nuclei fname = &#39;/path_to_capture_area_tif/Lieber_Institute_OTS-20-7748_rush_posterior_A1.tif&#39;; M = 3; refineVNS(fname,N) The color cluster before and after refining is shown below. "],["step-3-run-spaceranger.html", "3 Step 3: Run spaceranger", " 3 Step 3: Run spaceranger The following links and the flowchart provide useful information for running spaceranger on histology images. Blog post on running spaceranger on JHPCE, link to the github repo for running spaceranger, video tutorial etc. flow chart for running spaceranger The output files scalefactors_json.json and tissue_positions_list.csv from the spaceranger saved in the spatial folder, are required for the following image processing steps. "],["step-4-spotspotcheck-for-quality-check-on-nuclei-segmentations-and-counts.html", "4 Step 4: spotspotcheck for quality check on nuclei segmentations and counts", " 4 Step 4: spotspotcheck for quality check on nuclei segmentations and counts It is a matlab GUI for performing quality check on the nuclei segmentations from Step2. It also gives the nuclei count in each spot and provides an option to save/concatenate the count data to the tissue_positions_list.csv file. We will extract the metrics like spot diameter, distance between spots from the scalefactors_json.json and number of spots from tissue_positions_list.csv to reconstruct the spot grid for spotspotcheck. Describe what each column and row are in the tissue_positions_list.csv link to the video tutorial on the spotspotcheck GUI by Jeo Catallini Commands to run on matlab to perform nuclei counting per spot and adding the same as new column to tissue_positions_list.csv code and output for the command goes here "],["step-5-atlasaligner.html", "5 Step 5: AtlasAligner", " 5 Step 5: AtlasAligner "],["r-session-information.html", "R session information", " R session information Details on the R version used for making this book. The source code is available at LieberInstitute/VisiumLIBD. ## Load the package at the top of your script library(&quot;sessioninfo&quot;) ## Reproducibility information options(width = 120) session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.3 (2020-10-10) ## os Ubuntu 20.04 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2021-06-10 ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [2] RSPM (R 4.0.3) ## bookdown 0.21 2020-10-13 [1] RSPM (R 4.0.2) ## cli 2.3.0 2021-01-31 [2] RSPM (R 4.0.3) ## digest 0.6.27 2020-10-24 [2] RSPM (R 4.0.3) ## evaluate 0.14 2019-05-28 [2] RSPM (R 4.0.3) ## glue 1.4.2 2020-08-27 [2] RSPM (R 4.0.3) ## htmltools 0.5.1.1 2021-01-22 [2] RSPM (R 4.0.3) ## knitr 1.31 2021-01-27 [2] RSPM (R 4.0.3) ## magrittr 2.0.1 2020-11-17 [2] RSPM (R 4.0.3) ## rlang 0.4.10 2020-12-30 [2] RSPM (R 4.0.3) ## rmarkdown 2.6 2020-12-14 [1] RSPM (R 4.0.3) ## rstudioapi 0.13 2020-11-12 [2] RSPM (R 4.0.3) ## sessioninfo * 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [2] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [2] RSPM (R 4.0.3) ## withr 2.4.1 2021-01-26 [2] RSPM (R 4.0.3) ## xfun 0.21 2021-02-10 [2] RSPM (R 4.0.3) ## yaml 2.2.1 2020-02-01 [2] RSPM (R 4.0.3) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library proc.time() ## user system elapsed ## 0.579 0.140 0.570 This book was last updated at 2021-06-10 21:21:03. "]]
